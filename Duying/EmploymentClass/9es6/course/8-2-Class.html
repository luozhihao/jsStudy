<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>class</title>
</head>
<body>
  <h1>
    class
  </h1>
  <ul>
    <li>
        总结：
        <p>必须用new来执行，否则报错</p>
        <p>枚举Person原型上的属性，class定义构造函数的原型的属性都是浅粉色的，不能枚举</p>
        <p>静态属性是放到函数上、不是放到原型上。</p>
    </li>
  </ul>
  <h1>查漏补缺</h1>
  <ul>
    <li>es5中生成实例化对象用new 构造函数()，
      <p>缺点是和面向对象语言（Java、c++）差别太大，所以有了语法糖</p>
      es6用class(类的概念)，让对象原型的写法更加清晰、更像面向对象编程的语法</li>
      <p>es6中construct构造方法对应es5中构造函数</p>
      <li>写法注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</li>
      <li>事实上，类的所有方法都定义在类的prototype属性上面</li>
  </ul>
  <script>
    function Kuozhan(a,b){
      [a,b] = [b,a];//一行代码翻转a和b的值
      console.log(a,b);
      this.a = 'a'+a;
      this.b = 'b'+b;
    }
    Kuozhan.prototype = {
      name : '我们能枚举',
      shuxing : '可枚举'
    }
    var kuozhan = new Kuozhan(1,2);
    for (const key in kuozhan) {
      // if (kuozhan.hasOwnProperty(key)) {
        console.log( kuozhan[key]);//如果不用hasOwnProperty过滤，是可以枚举prototype上的属性的
      // }
    }
    // 语法糖，没有改变es5函数的本质，但是更简单高效。
    class Person{
      // 静态属性定义 - 必须经过方法包装，返回一个属性
      static address(){
        return 'china';
      }
      // static address = 'china'; //es7的写法，es6不支持这么写
      // 私有属性定义
      constructor (name,age=20){
        //es6中函数的写法,constructor创建实例化对象的私有属性
        this.name = name;
        this.age = age;
        var myVal = '这才是真正的私有属性？';
        this.siyouFun = function(){
          console.log('siyouFun')
          return '实例化私有方法'
        }
        /* return {返回一个对象，new 构造函数后的实例化对象就是这个，同es5中构造函数的表现
          a: 1
        } */
      }
      // 在Person.prototype上添加公有方法
      eat(){
        console.log('eat')
        return "i'm eating";
      }
      // 不能添加公有属性
      // fatherName = 'guo';//这是es7的写法，不支持的浏览器会报错。虽然我mac上边的chrome没有报错，但是公司电脑的qq浏览器就报错了
      
    }

    console.log(Person);
    var person = new Person('xingorg1',12)
    console.log(person);
    person.siyouFun();//调用私有方法
    person.eat();//调用原型方法，等同Person.prototype.eat
    console.log(person.fatherName)
    console.log(Person.address())

    class Man extends Person{//继承Person身上的静态属性、Person.prototype也被当做man.__proto__（即Man.prototype）的__proto__了。说明Man.prototype是Person构造出来的对象
      constructor(name,hobby){
        super(name); // === Person.call(this),继承实例化对象的私有属性
        this.hobby = hobby;
      }
      sing(){
        console.log("i can sing");
        return 'sing'
      }
    }
    var man = new Man('xiao ming','sleep');
    console.log(man);

    // 

  </script>
</body>
</html>